const std = @import("std");
const parser = @import("c_parse.zig");

const ExceptionsPossible = packed struct {
    failure: bool = true,
    cont: bool = true,
    domain: bool = true,
    range: bool = true,
    invalid_ptr: bool = true,
    invalid_value: bool = true,
    generic_failure: bool = true,
    factor: bool = true,
    sanity: bool = true,
    no_mem: bool = true,
    bad_func: bool = true,
    run_away: bool = true,
    max_iter: bool = true,
    zero_div: bool = true,
    bad_tol: bool = true,
    tol: bool = true,
    underflow: bool = true,
    overflow: bool = true,
    loss: bool = true,
    round: bool = true,
    bad_len: bool = true,
    not_square: bool = true,
    singular: bool = true,
    diverge: bool = true,
    unsup: bool = true,
    unimpl: bool = true,
    cache: bool = true,
    table: bool = true,
    no_prog: bool = true,
    no_prog_j: bool = true,
    tol_f: bool = true,
    tol_x: bool = true,
    tol_g: bool = true,
    eof: bool = true,
};

// argument, converted to slice, is checked as
// slice.len == max - min, only in debug builds!
pub const BoundCheckedArg = struct { idx: usize, min: []u8, max: []u8 };

// Autogenerated reasonably, some stuff manually input
pub const FunctionConfig = struct {
    fun: parser.ParsedCFunction,
    // Only if return type is int (of fun) These exceptions then will be
    // handled as Zig errors! Any unhandled exception will return in a
    // (debug) runtime error, to facilitate catching forgotten exceptions
    exceptions: ExceptionsPossible,
    // Indices into the function arguments, that are converted instead to an anonymous return struct
    // (or single return value if only one is present)
    ret_args: ?[]usize,
    // Arguments which are bound checked (turned into a slice and its len checked)
    // (Note that such arguments may not be ret_args! This prevents allocations inside the function)
    bound_checked_args: ?[]BoundCheckedArg,
};

pub fn make_default_config(fun: parser.ParsedCFunction) !FunctionConfig {
    var out: FunctionConfig = undefined;
    out.fun = fun;
    // try to parse exceptions from doc, if any

    out.ret_args = null;

    return out;
}

pub fn has_errors(cfg: FunctionConfig) bool {
    return std.mem.eql(u8, cfg.fun.rettype, "int");
}

pub fn build_errors(alloc: std.mem.Allocator, cfg: FunctionConfig) ![]u8 {
    var out = std.ArrayList(u8).init(alloc);
    if (!has_errors(cfg)) {
        return out.toOwnedSlice();
    }

    try out.appendSlice("error{");
    if (cfg.exceptions.failure) {
        try out.appendSlice("Failure,");
    }
    if (cfg.exceptions.cont) {
        try out.appendSlice("Continue,");
    }
    if (cfg.exceptions.domain) {
        try out.appendSlice("Domain,");
    }
    if (cfg.exceptions.range) {
        try out.appendSlice("Range,");
    }
    if (cfg.exceptions.invalid_ptr) {
        try out.appendSlice("InvalidPointer,");
    }
    if (cfg.exceptions.invalid_value) {
        try out.appendSlice("InvalidValue,");
    }
    if (cfg.exceptions.generic_failure) {
        try out.appendSlice("GenericFailure,");
    }
    if (cfg.exceptions.factor) {
        try out.appendSlice("Factorization,");
    }
    if (cfg.exceptions.sanity) {
        try out.appendSlice("SanityCheck,");
    }
    if (cfg.exceptions.no_mem) {
        try out.appendSlice("NoMemory,");
    }
    if (cfg.exceptions.bad_func) {
        try out.appendSlice("BadFunction,");
    }
    if (cfg.exceptions.run_away) {
        try out.appendSlice("RunAway,");
    }
    if (cfg.exceptions.max_iter) {
        try out.appendSlice("MaxIter,");
    }
    if (cfg.exceptions.zero_div) {
        try out.appendSlice("ZeroDiv,");
    }
    if (cfg.exceptions.bad_tol) {
        try out.appendSlice("BadTolerance,");
    }
    if (cfg.exceptions.tol) {
        try out.appendSlice("Tolerance,");
    }
    if (cfg.exceptions.underflow) {
        try out.appendSlice("Underflow,");
    }
    if (cfg.exceptions.overflow) {
        try out.appendSlice("Overflow,");
    }
    if (cfg.exceptions.loss) {
        try out.appendSlice("LossOfAccuracy,");
    }
    if (cfg.exceptions.round) {
        try out.appendSlice("Roundoff,");
    }
    if (cfg.exceptions.bad_len) {
        try out.appendSlice("BadLength,");
    }
    if (cfg.exceptions.not_square) {
        try out.appendSlice("NotSquare,");
    }
    if (cfg.exceptions.singular) {
        try out.appendSlice("Singularity,");
    }
    if (cfg.exceptions.diverge) {
        try out.appendSlice("Divergent,");
    }
    if (cfg.exceptions.unsup) {
        try out.appendSlice("Unsupported,");
    }
    if (cfg.exceptions.unimpl) {
        try out.appendSlice("Unimplemented,");
    }
    if (cfg.exceptions.cache) {
        try out.appendSlice("CacheLimit,");
    }
    if (cfg.exceptions.table) {
        try out.appendSlice("TableLimit,");
    }
    if (cfg.exceptions.no_prog) {
        try out.appendSlice("NoProgress,");
    }
    if (cfg.exceptions.no_prog_j) {
        try out.appendSlice("NoProgressJacobian,");
    }
    if (cfg.exceptions.tol_f) {
        try out.appendSlice("ToleranceF,");
    }
    if (cfg.exceptions.tol_x) {
        try out.appendSlice("ToleranceX,");
    }
    if (cfg.exceptions.tol_g) {
        try out.appendSlice("ToleranceG,");
    }
    if (cfg.exceptions.eof) {
        try out.appendSlice("Eof,");
    }

    try out.appendSlice("}");

    return try out.toOwnedSlice();
}

pub fn build_ret(alloc: std.mem.Allocator, cfg: FunctionConfig) ![]u8 {
    var out = std.ArrayList(u8).init(alloc);
    _ = cfg;
    return out.toOwnedSlice();
}

pub fn build_args(alloc: std.mem.Allocator, cfg: FunctionConfig) ![]u8 {
    var out = std.ArrayList(u8).init(alloc);
    _ = cfg;
    return out.toOwnedSlice();
}
